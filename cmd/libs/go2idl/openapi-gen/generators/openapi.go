/*
Copyright 2016 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package generators

import (
	"bytes"
	"fmt"
	"io"
	"path/filepath"
	"reflect"
	"sort"
	"strings"

	"k8s.io/apimachinery/pkg/openapi"
	"k8s.io/gengo/args"
	"k8s.io/gengo/generator"
	"k8s.io/gengo/namer"
	"k8s.io/gengo/types"

	"github.com/cbroglie/mustache"
	"github.com/golang/glog"
	"regexp"
)

// This is the comment tag that carries parameters for open API generation.
const tagName = "k8s:openapi-gen"
const tagOptional = "optional"

// Known values for the tag.
const (
	tagValueTrue       = "true"
	tagValueFalse      = "false"
	tagExtensionPrefix = "x-kubernetes-"
	tagPatchStrategy   = "patch-strategy"
	tagPatchMergeKey   = "patch-merge-key"
)

func getOpenAPITagValue(comments []string) []string {
	return types.ExtractCommentTags("+", comments)[tagName]
}

func hasOpenAPITagValue(comments []string, value string) bool {
	tagValues := getOpenAPITagValue(comments)
	for _, val := range tagValues {
		if val == value {
			return true
		}
	}
	return false
}

// hasOptionalTag returns true if the member has +optional in its comments or
// omitempty in its json tags.
func hasOptionalTag(m *types.Member) bool {
	hasOptionalCommentTag := types.ExtractCommentTags(
		"+", m.CommentLines)[tagOptional] != nil
	hasOptionalJsonTag := strings.Contains(
		reflect.StructTag(m.Tags).Get("json"), "omitempty")
	return hasOptionalCommentTag || hasOptionalJsonTag
}

func getPatchStrategy(comments []string) string {}

type identityNamer struct{}

func (_ identityNamer) Name(t *types.Type) string {
	return t.Name.String()
}

var _ namer.Namer = identityNamer{}

// NameSystems returns the name system used by the generators in this package.
func NameSystems() namer.NameSystems {
	return namer.NameSystems{
		"raw":           namer.NewRawNamer("", nil),
		"sorting_namer": identityNamer{},
	}
}

// DefaultNameSystem returns the default name system for ordering the types to be
// processed by the generators in this package.
func DefaultNameSystem() string {
	return "sorting_namer"
}

func Packages(context *generator.Context, arguments *args.GeneratorArgs) generator.Packages {
	boilerplate, err := arguments.LoadGoBoilerplate()
	if err != nil {
		glog.Fatalf("Failed loading boilerplate: %v", err)
	}
	header := append([]byte(fmt.Sprintf("// +build !%s\n\n", arguments.GeneratedBuildTag)), boilerplate...)
	header = append(header, []byte(
		`
// This file was autogenerated by openapi-gen. Do not edit it manually!

`)...)

	if err := context.AddDir(arguments.OutputPackagePath); err != nil {
		glog.Fatalf("Failed to load output package: %v", err)
	}
	pkg := context.Universe[arguments.OutputPackagePath]
	if pkg == nil {
		glog.Fatalf("Got nil output package")
	}
	return generator.Packages{
		&generator.DefaultPackage{
			PackageName: strings.Split(filepath.Base(pkg.Path), ".")[0],
			PackagePath: pkg.Path,
			HeaderText:  header,
			GeneratorFunc: func(c *generator.Context) (generators []generator.Generator) {
				return []generator.Generator{NewOpenAPIGen(arguments.OutputFileBaseName, pkg, context)}
			},
			FilterFunc: func(c *generator.Context, t *types.Type) bool {
				// There is a conflict between this codegen and codecgen, we should avoid types generated for codecgen
				if strings.HasPrefix(t.Name.Name, "codecSelfer") {
					return false
				}
				pkg := context.Universe.Package(t.Name.Package)
				if hasOpenAPITagValue(pkg.Comments, tagValueTrue) {
					return !hasOpenAPITagValue(t.CommentLines, tagValueFalse)
				}
				if hasOpenAPITagValue(t.CommentLines, tagValueTrue) {
					return true
				}
				return false
			},
		},
	}
}

const (
	openAPICommonPackagePath = "k8s.io/apimachinery/pkg/openapi"
)

// openApiGen produces a file with auto-generated OpenAPI functions.
type openAPIGen struct {
	generator.DefaultGen
	// TargetPackage is the package that will get GetOpenAPIDefinitions function returns all open API definitions.
	targetPackage *types.Package
	imports       namer.ImportTracker
	context       *generator.Context
	template      templateRoot
}

func NewOpenAPIGen(sanitizedName string, targetPackage *types.Package, context *generator.Context) generator.Generator {
	return &openAPIGen{
		DefaultGen: generator.DefaultGen{
			OptionalName: sanitizedName,
		},
		imports:       generator.NewImportTracker(),
		targetPackage: targetPackage,
		context:       context,
		template:      templateRoot{
			Definitions: []templateDefinition{},
		},
	}
}

func (g *openAPIGen) Namers(c *generator.Context) namer.NameSystems {
	// Have the raw namer for this file track what it imports.
	return namer.NameSystems{
		"raw": namer.NewRawNamer(g.targetPackage.Path, g.imports),
	}
}

func (g *openAPIGen) Filter(c *generator.Context, t *types.Type) bool {
	// There is a conflict between this codegen and codecgen, we should avoid types generated for codecgen
	if strings.HasPrefix(t.Name.Name, "codecSelfer") {
		return false
	}
	return true
}

func (g *openAPIGen) isOtherPackage(pkg string) bool {
	if pkg == g.targetPackage.Path {
		return false
	}
	if strings.HasSuffix(pkg, "\""+g.targetPackage.Path+"\"") {
		return false
	}
	return true
}

func (g *openAPIGen) Imports(c *generator.Context) []string {
	importLines := []string{}
	for _, singleImport := range g.imports.ImportLines() {
		importLines = append(importLines, singleImport)
	}
	importLines = append(importLines, "spec \"github.com/go-openapi/spec\"", "openapi \"k8s.io/apimachinery/pkg/openapi\"")
	return importLines
}

func (g *openAPIGen) Init(c *generator.Context, w io.Writer) error {
	return nil
}

func (g *openAPIGen) Finalize(c *generator.Context, w io.Writer) error {
	content, err := mustache.Render(template, g.template)
	if err != nil {
		return err
	}
	regex, err := regexp.Compile("\n\\s*\n")
	if err != nil {
		return err
	}
	content = regex.ReplaceAllString(content, "\n")
	io.WriteString(w, content)
	// Generate the actual thing here
	return nil
}

func (g *openAPIGen) GenerateType(c *generator.Context, t *types.Type, w io.Writer) error {
	glog.V(5).Infof("generating for type %v", t)
	def, err := newOpenAPITypeWriter(g.Namers(c)["raw"]).generate(t)
	if err != nil {
		return err
	}
	if def != nil {
		g.template.Definitions = append(g.template.Definitions, *def)
	}
	return nil
}

func getJsonTags(m *types.Member) []string {
	jsonTag := reflect.StructTag(m.Tags).Get("json")
	if jsonTag == "" {
		return []string{}
	}
	return strings.Split(jsonTag, ",")
}

func getPatchStrategyTags(m *types.Member) []string {
	jsonTag := reflect.StructTag(m.Tags).Get("patchStrategy")
	if jsonTag == "" {
		return []string{}
	}
	return strings.Split(jsonTag, ",")
}

func getReferableName(m *types.Member) string {
	jsonTags := getJsonTags(m)
	if len(jsonTags) > 0 {
		if jsonTags[0] == "-" {
			return ""
		} else {
			return jsonTags[0]
		}
	} else {
		return m.Name
	}
}

func shouldInlineMembers(m *types.Member) bool {
	jsonTags := getJsonTags(m)
	return len(jsonTags) > 1 && jsonTags[1] == "inline"
}

type openAPITypeWriter struct {
	refTypes               map[string]*types.Type
	GetDefinitionInterface *types.Type
	rawNamer namer.Namer
}

func newOpenAPITypeWriter(n namer.Namer) openAPITypeWriter {
	return openAPITypeWriter{
		refTypes:      map[string]*types.Type{},
		rawNamer: n,
	}
}

func hasOpenAPIDefinitionMethod(t *types.Type) bool {
	for mn, mt := range t.Methods {
		if mn != "OpenAPIDefinition" {
			continue
		}
		if len(mt.Signature.Parameters) != 0 || len(mt.Signature.Results) != 1 {
			return false
		}
		r := mt.Signature.Results[0]
		if r.Name.Name != "OpenAPIDefinition" || r.Name.Package != openAPICommonPackagePath {
			return false
		}
		return true
	}
	return false
}

func (g openAPITypeWriter) generateMembers(t *types.Type, required []string) ([]string, []templateProperty, error) {
	temps := []templateProperty{}
	for _, m := range t.Members {
		if hasOpenAPITagValue(m.CommentLines, tagValueFalse) {
			continue
		}
		if shouldInlineMembers(&m) {
			required, temps2, err := g.generateMembers(m.Type, required)
			if err != nil {
				return required, temps, err
			}
			temps = append(temps, temps2...)
			continue
		}
		name := getReferableName(&m)
		if name == "" {
			continue
		}
		if !hasOptionalTag(&m) {
			required = append(required, name)
		}
		temp, err := g.generateProperty(&m)
		if err != nil {
			return required, temps, err
		}
		if temp != nil {
			temps = append(temps, *temp)
		}
	}
	return required, temps, nil
}

func (g openAPITypeWriter) generate(t *types.Type) (*templateDefinition, error) {
	// Only generate for struct type and ignore the rest
	switch t.Kind {
	case types.Struct:
		def := templateDefinition{}
		def.Name = t.Name.String()
		if hasOpenAPIDefinitionMethod(t) {
			def.OpenAPIDefinition = &templateOpenAPIDefinition{
				TypeName: g.rawNamer.Name(t),
			}
			return &def, nil
		}
		def.Description = g.generateDescription(t.CommentLines)
		required, temps, err := g.generateMembers(t, []string{})
		if err != nil {
			return nil, err
		}
		def.Properties = temps
		if len(required) > 0 {
			def.Required = required
			def.HasRequired = true
		}
		// Map order is undefined, sort them or we may get a different file generated each time.
		keys := []string{}
		for k := range g.refTypes {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			v := g.refTypes[k]
			if t, _ := openapi.GetOpenAPITypeFormat(v.String()); t != "" {
				// This is a known type, we do not need a reference to it
				// Will eliminate special case of time.Time
				continue
			}
			def.Dependencies = append(def.Dependencies, k)
		}
		extTemp, err := g.generateExtensions(t.CommentLines)
		if err != nil {
			return nil, err
		}
		def.Extensions = extTemp
		return &def, nil
	}
	return nil, nil
}

func (g openAPITypeWriter) generateExtensions(CommentLines []string) (templateExtensions, error) {
	temp := templateExtensions{}
	tagValues := getOpenAPITagValue(CommentLines)
	for _, val := range tagValues {
		if strings.HasPrefix(val, tagExtensionPrefix) {
			parts := strings.SplitN(val, ":", 2)
			if len(parts) != 2 {
				return temp, fmt.Errorf("Invalid extension value: %v", val)
			}
			temp.Extension = append(temp.Extension, struct {Name, Value string}{parts[0], parts[1]})
		}
	}
	if ps := getPatchStrategy(CommentLines); ps != "" {
		temp.Extension = append(...)
	}
	if len(temp.Extension) > 0 {
		return temp, nil
	}
	return nil, nil
}

func (g openAPITypeWriter) generateDescription(CommentLines []string) string {
	var buffer bytes.Buffer
	delPrevChar := func() {
		if buffer.Len() > 0 {
			buffer.Truncate(buffer.Len() - 1) // Delete the last " " or "\n"
		}
	}

	for _, line := range CommentLines {
		// Ignore all lines after ---
		if line == "---" {
			break
		}
		line = strings.TrimRight(line, " ")
		leading := strings.TrimLeft(line, " ")
		switch {
		case len(line) == 0: // Keep paragraphs
			delPrevChar()
			buffer.WriteString("\n\n")
		case strings.HasPrefix(leading, "TODO"): // Ignore one line TODOs
		case strings.HasPrefix(leading, "+"): // Ignore instructions to go2idl
		default:
			if strings.HasPrefix(line, " ") || strings.HasPrefix(line, "\t") {
				delPrevChar()
				line = "\n" + line + "\n" // Replace it with newline. This is useful when we have a line with: "Example:\n\tJSON-someting..."
			} else {
				line += " "
			}
			buffer.WriteString(line)
		}
	}

	postDoc := strings.TrimRight(buffer.String(), "\n")
	postDoc = strings.Replace(postDoc, "\\\"", "\"", -1) // replace user's \" to "
	postDoc = strings.Replace(postDoc, "\"", "\\\"", -1) // Escape "
	postDoc = strings.Replace(postDoc, "\n", "\\n", -1)
	postDoc = strings.Replace(postDoc, "\t", "\\t", -1)
	postDoc = strings.Trim(postDoc, " ")
	if postDoc != "" {
		return postDoc
	}
	return ""
}

func (g openAPITypeWriter) generateProperty(m *types.Member) (*templateProperty, error) {
	temp := templateProperty{}
	name := getReferableName(m)
	if name == "" {
		return nil, nil
	}
	temp.Name = name
	exTemp, err := g.generateExtensions(m.CommentLines)
	if err != nil {
		return nil, err
	}
	if ps := getPatchStrategy(CommentLines); ps != "" {
		// if struct tag is there
	}
	if ps := getPatchStrategy(CommentLines); ps != "" {
		// if struct tag is there
	}
	temp.Extensions = exTemp
	temp.Description = g.generateDescription(m.CommentLines)
	jsonTags := getJsonTags(m)
	if len(jsonTags) > 1 && jsonTags[1] == "string" {
		temp.SimpleProperty =  g.generateSimpleProperty("string", "")
		return &temp, nil
	}
	t := resolveAliasAndPtrType(m.Type)
	// If we can get a openAPI type and format for this type, we consider it to be simple property
	typeString, format := openapi.GetOpenAPITypeFormat(t.String())
	if typeString != "" {
		temp.SimpleProperty =  g.generateSimpleProperty(typeString, format)
		return &temp, nil
	}
	switch t.Kind {
	case types.Builtin:
		return nil, fmt.Errorf("please add type %v to getOpenAPITypeFormat function", t)
	case types.Map:
		mapTemp, err := g.generateMapProperty(t)
		if err != nil {
			return nil, err
		}
		temp.MapProperty = mapTemp
	case types.Slice, types.Array:
		sliceTemp, err := g.generateSliceProperty(t)
		if err != nil {
			return nil, err
		}
		temp.SliceProperty = sliceTemp
	case types.Struct, types.Interface:
		temp.ReferenceProperty = g.generateReferenceProperty(t)
	default:
		return nil, fmt.Errorf("cannot generate spec for type %v", t)
	}
	return &temp, nil
}

func (g openAPITypeWriter) generateSimpleProperty(typeString, format string) *templateSimpleProperty {
	return &templateSimpleProperty{TypeString: typeString, Format: format}
}

func (g openAPITypeWriter) generateReferenceProperty(t *types.Type) *templateReferenceProperty {
	g.refTypes[t.Name.String()] = t
	return &templateReferenceProperty{Name: t.Name.String()}
}

func resolveAliasAndPtrType(t *types.Type) *types.Type {
	var prev *types.Type
	for prev != t {
		prev = t
		if t.Kind == types.Alias {
			t = t.Underlying
		}
		if t.Kind == types.Pointer {
			t = t.Elem
		}
	}
	return t
}

func (g openAPITypeWriter) generateMapProperty(t *types.Type) (*templateMapProperty, error) {
	temp := templateMapProperty{}
	keyType := resolveAliasAndPtrType(t.Key)
	elemType := resolveAliasAndPtrType(t.Elem)

	// According to OpenAPI examples, only map from string is supported
	if keyType.Name.Name != "string" {
		return nil, fmt.Errorf("map with non-string keys are not supported by OpenAPI in %v", t)
	}
	typeString, format := openapi.GetOpenAPITypeFormat(elemType.String())
	if typeString != "" {
		temp.SimpleProperty =  g.generateSimpleProperty(typeString, format)
		return &temp, nil
	}
	switch elemType.Kind {
	case types.Builtin:
		return nil, fmt.Errorf("please add type %v to getOpenAPITypeFormat function.", elemType)
	case types.Struct:
		temp.ReferenceProperty = g.generateReferenceProperty(t.Elem)
	case types.Slice, types.Array:
		sliceTemp, err := g.generateSliceProperty(elemType)
		if err != nil {
			return nil, err
		}
		temp.SliceProperty = sliceTemp
	default:
		return nil, fmt.Errorf("map Element kind %v is not supported in %v", elemType.Kind, t.Name)
	}
	return &temp, nil
}

func (g openAPITypeWriter) generateSliceProperty(t *types.Type) (*templateSliceProperty, error) {
	temp := templateSliceProperty{}
	elemType := resolveAliasAndPtrType(t.Elem)
	typeString, format := openapi.GetOpenAPITypeFormat(elemType.String())
	if typeString != "" {
		temp.SimpleProperty = g.generateSimpleProperty(typeString, format)
		return &temp, nil
	}
	switch elemType.Kind {
	case types.Builtin:
		return nil, fmt.Errorf("please add type %v to getOpenAPITypeFormat function.", elemType)
	case types.Struct:
		temp.ReferenceProperty = g.generateReferenceProperty(t.Elem)
	default:
		return nil, fmt.Errorf("slice Element kind %v is not supported in %v", elemType.Kind, t)
	}
	return &temp, nil
}


type templateRoot struct {
	Definitions []templateDefinition
}

type templateDefinition struct {
	OpenAPIDefinition *templateOpenAPIDefinition
	Name string
	Description interface{}
	Properties []templateProperty
	Required []string
	HasRequired bool
	Dependencies []string
	Extensions templateExtensions
}

type templateOpenAPIDefinition struct {
	TypeName string  // use namer here
}

type templateProperty struct {
	Name string
	Extensions templateExtensions
	Description interface{}
	SimpleProperty *templateSimpleProperty
	MapProperty *templateMapProperty
	SliceProperty *templateSliceProperty
	ReferenceProperty *templateReferenceProperty
}

type templateExtensions struct {
	Extension []struct {
		Name string
		Value string
	}
}

type templateSimpleProperty struct {
	TypeString string
	Format string
}

type templateMapProperty struct {
	SimpleProperty *templateSimpleProperty
	SliceProperty *templateSliceProperty
	ReferenceProperty *templateReferenceProperty
}

type templateSliceProperty struct {
	SimpleProperty *templateSimpleProperty
	ReferenceProperty *templateReferenceProperty
}

type templateReferenceProperty struct {
	Name string
}

var template string = `

func GetOpenAPIDefinitions(ref openapi.ReferenceCallback) map[string]openapi.OpenAPIDefinition {
    return map[string]openapi.OpenAPIDefinition{
        {{#Definitions}}
            "{{{Name}}}" :
                {{#OpenAPIDefinition}} {{{TypeName}}}{}.OpenAPIDefinition(), {{/OpenAPIDefinition}} {{^OpenAPIDefinition}} {
                    Schema: spec.Schema{
                        SchemaProps: spec.SchemaProps{
                            {{#Description}} Description: "{{{Description}}}",
                            {{/Description}}
                            Properties: map[string]spec.Schema{
                                {{#Properties}}
                                "{{{Name}}}": {
  				    {{#Extensions}}
				    spec.VendorExtensible: {
					Extensions: spec.Extensions{
					    {{#Extension}}
					    "{{{Name}}}": "{{{Value}}}",
					    {{/Extension}}
					},
			    	    },
				    {{/Extensions}}
                                    SchemaProps: spec.SchemaProps{
		                        {{#Description}} Description: "{{{Description}}}",
		                        {{/Description}}
                                        {{#SimpleProperty}}
                                            Type: []string{"{{{TypeString}}}"},
                                            Format: "{{{Format}}}",
                                        {{/SimpleProperty}}
                                        {{#MapProperty}}
                                            Type: []string{"object"},
                                            AdditionalProperties: &spec.SchemaOrBool{
                                                Schema: &spec.Schema{
                                                    SchemaProps: spec.SchemaProps{
                                                        {{#SimpleProperty}}
                                                            Type: []string{"{{{TypeString}}}"},
                                                            Format: "{{{Format}}}",
                                                        {{/SimpleProperty}}
                                                        {{#ReferenceProperty}}
                                                            Ref: ref("{{{Name}}}"),
                                                        {{/ReferenceProperty}}
                                                        {{#SliceProperty}}
                                                            Type: []string{"array"},
                                                            Items: &spec.SchemaOrArray{
                                                                    Schema: &spec.Schema{
                                                                    SchemaProps: spec.SchemaProps{
                                                                        {{#SimpleProperty}}
                                                                            Type: []string{"{{{TypeString}}}"},
                                                                            Format: "{{{Format}}}",
                                                                        {{/SimpleProperty}}
                                                                        {{#ReferenceProperty}}
                                                                            Ref: ref("{{{Name}}}"),
                                                                        {{/ReferenceProperty}}
                                                                    },
                                                                },
                                                            },
                                                        {{/SliceProperty}}
                                                    },
                                                },
                                            },
                                        {{/MapProperty}}
                                        {{#SliceProperty}}
                                            Type: []string{"array"},
                                            Items: &spec.SchemaOrArray{
                                                Schema: &spec.Schema{
                                                    SchemaProps: spec.SchemaProps{
                                                        {{#SimpleProperty}}
                                                            Type: []string{"{{{TypeString}}}"},
                                                            Format: "{{{Format}}}",
                                                        {{/SimpleProperty}}
                                                        {{#ReferenceProperty}}
                                                            Ref: ref("{{{Name}}}"),
                                                        {{/ReferenceProperty}}
                                                    },
                                                },
                                            },
                                        {{/SliceProperty}}
                                        {{#ReferenceProperty}}
                                            Ref: ref("{{{Name}}}"),
                                        {{/ReferenceProperty}}
                                    },
                                },
                                {{/Properties}}
				{{#Extensions}}
				spec.VendorExtensible: {
					Extensions: spec.Extensions{
					    {{#Extension}}
					    "{{{Name}}}": "{{{Value}}}",
					    {{/Extension}}
					},
				},
				{{/Extensions}}
                            },
                                {{#HasRequired}} Required: []string{ {{#Required}}"{{{.}}}", {{/Required}} },{{/HasRequired}}
                        },
                    },
                                Dependencies: []string{
                                	{{#Dependencies}}"{{{.}}}", {{/Dependencies}} },
                }, {{/OpenAPIDefinition}}
        {{/Definitions}}
    }
}
`
